<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Attention Bias Test</title>
<style>
 body {
  margin: 0;
  text-align: center;
  font-family: Arial, sans-serif;
  overflow: hidden; /* avoid scrollbars in fullscreen */
 }

 #displayCanvas {
  border: 1px solid #ccc;
  width: 100vw;
  height: 100vh;
  margin: 0;
  box-sizing: border-box; /* keep border within viewport */
  display: block;
  cursor: none;
 }

 #slides {
  display:none;
  display:flex;
  width:100vw;
  height:100vh;
  justify-content:center;
  align-items:center;
}
 .slide-img {
  width:25vw;
  height:25vh;
  margin:0 2vw;
  object-fit:contain;
}
</style>
</head>
<body>
<div id="startScreen">
 <h1>Attention Bias Test</h1>
 <button id="beginBtn">Begin</button>
</div>
<canvas id="displayCanvas" style="display:none;"></canvas>

<div id="slides">
 <img id="imgLeft" class="slide-img" src="" alt="left">
 <img id="imgRight" class="slide-img" src="" alt="right">
</div>
<div id="thankYou" style="display:none;">
 <h2>Thank you for completing test</h2>
</div>
<script>
const beginBtn = document.getElementById('beginBtn');
const startScreen = document.getElementById('startScreen');
const canvas = document.getElementById('displayCanvas');
const ctx = canvas.getContext('2d');
const slidesDiv = document.getElementById('slides');
const imgLeft = document.getElementById('imgLeft');
const imgRight = document.getElementById('imgRight');
const thankYou = document.getElementById('thankYou');
let calibInterval = null;
let slideInterval = null;
let currentSlide = 0;
const TOTAL_SLIDES = 10;
const SLIDE_DURATION = 5000; // 5s

let isSpaceDown = false;
let calibrationActive = false;

document.addEventListener('keydown', (event) => {
    if (calibrationActive && event.code === 'Space') {
        isSpaceDown = true;
        event.preventDefault();
    }
});
document.addEventListener('keyup', (event) => {
    if (calibrationActive && event.code === 'Space') {
        isSpaceDown = false;
    }
});

function drawCalibration(info) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    if (info.type === 'instruction_text' || info.type === 'message') {
        ctx.fillStyle = 'black';
        ctx.font = '30px Arial';
        const lines = info.text.split('\n');
        lines.forEach((line, i) => {
            const m = ctx.measureText(line);
            ctx.fillText(line, (canvas.width - m.width) / 2, 150 + i * 50);
        });
    } else if (info.type === 'fixation_dot' || info.type === 'test_dot') {
        if (!info.target_point) return;
        
        const [targetX, targetY] = info.target_point;

        if (info.outer_circle_radius) {
            ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(targetX, targetY, info.outer_circle_radius, 0, Math.PI * 2);
            ctx.stroke();
        }

        ctx.fillStyle = info.is_point_completed ? 'green' : 'red';
        ctx.beginPath();
        ctx.arc(targetX, targetY, info.inner_circle_radius, 0, Math.PI * 2);
        ctx.fill();

        if (info.type === 'test_dot' && info.estimated_gaze) {
            const [gx, gy] = info.estimated_gaze;
            ctx.strokeStyle = 'blue';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(gx - 10, gy);
            ctx.lineTo(gx + 10, gy);
            ctx.moveTo(gx, gy - 10);
            ctx.lineTo(gx, gy + 10);
            ctx.stroke();
        }
    }
}


function pollCalibration() {
    fetch('/calibration_step?space_down=' + (isSpaceDown ? '1' : '0')).then(r => r.json()).then(data => {
        if (data.status === 'not_calibrating' || data.status === 'error') {
            console.error("Calibration error or not active, stopping poll");
            clearInterval(calibInterval);
            calibrationActive = false;
            return;
        }

        drawCalibration(data.display_info);
        if (data.status === 'finished_all') {
            clearInterval(calibInterval);
            calibrationActive = false;
            canvas.style.display = 'none';
            slidesDiv.style.display = 'flex';
            startSlides();
        }
    }).catch(err => {
        console.error("Polling failed:", err);
        clearInterval(calibInterval);
        calibrationActive = false;
    });
}


function startSlides() {
    fetch('/start_slides');
    showSlide(0);
    slideInterval = setInterval(() => {
        currentSlide++;
        if (currentSlide >= TOTAL_SLIDES) {
            clearInterval(slideInterval);
            finishTest();
        } else {
            showSlide(currentSlide);
        }
    }, SLIDE_DURATION);
    recordGaze();
}

function showSlide(idx) {
    imgLeft.src = `/static/slides/slide${idx+1}_left.svg`;
    imgRight.src = `/static/slides/slide${idx+1}_right.svg`;
    fetch(`/set_slide/${idx}`);
}

function recordGaze() {
    if (!slideInterval) return; // stop recording if slides are done
    fetch(`/record_gaze?slide=${currentSlide}`);
    setTimeout(recordGaze, 100); // 10 Hz
}

function finishTest() {
    slidesDiv.style.display = 'none';
    thankYou.style.display = 'block';
    if (document.exitFullscreen) {
        document.exitFullscreen();
    } else if (document.webkitExitFullscreen) {
        document.webkitExitFullscreen();
    }
    fetch('/finish');
}

beginBtn.onclick = () => {
    const docEl = document.documentElement;
    const requestFS = docEl.requestFullscreen ||
        docEl.webkitRequestFullscreen ||
        docEl.mozRequestFullScreen ||
        docEl.msRequestFullscreen;
    let fsPromise = Promise.resolve();
    if (requestFS) {
        const result = requestFS.call(docEl);
        if (result && typeof result.then === 'function') fsPromise = result;
    }

    fsPromise.finally(() => {
        startScreen.style.display = 'none';
        canvas.style.display = 'block';
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        fetch('/start_test', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                width: window.innerWidth,
                height: window.innerHeight
            })
        }).then(() => {
            calibrationActive = true;
            calibInterval = setInterval(pollCalibration, 100);
        });
    });
};
</script>
</body>
</html>